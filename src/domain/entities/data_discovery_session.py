"""
Domain entities for Data Discovery sessions.

These entities represent user data discovery sessions for discovering, testing,
and validating data sources before adding them to Research Spaces.
"""

from collections.abc import Sequence
from datetime import UTC, date, datetime
from enum import Enum
from typing import assert_never
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field, field_validator

from src.domain.entities.user_data_source import SourceType
from src.type_definitions.common import JSONObject


class QueryParameterType(str, Enum):
    """Types of query parameters supported by data sources."""

    GENE = "gene"
    TERM = "term"
    GENE_AND_TERM = "gene_and_term"
    NONE = "none"
    API = "api"  # Special type for AI models and programmatic access


class TestResultStatus(str, Enum):
    """Status of a query test result."""

    __test__ = False  # Prevent pytest from treating this Enum as a test class

    PENDING = "pending"
    SUCCESS = "success"
    ERROR = "error"
    TIMEOUT = "timeout"
    VALIDATION_FAILED = "validation_failed"


class SourceCatalogEntry(BaseModel):
    """
    Domain entity representing an entry in the data source catalog.

    This represents a discoverable data source that users can test
    and potentially add to their Research Spaces.
    """

    model_config = ConfigDict(frozen=True)

    # Identity
    id: str = Field(..., description="Unique identifier for the catalog entry")
    name: str = Field(..., min_length=1, max_length=200, description="Display name")

    # Classification
    category: str = Field(..., description="Category this source belongs to")
    subcategory: str | None = Field(None, description="Optional subcategory")

    # Description and metadata
    description: str = Field(..., max_length=1000, description="Detailed description")
    tags: list[str] = Field(default_factory=list, description="Searchable tags")
    source_type: SourceType = Field(
        default=SourceType.API,
        description="Underlying ingestion type (api, file_upload, database, etc.)",
    )

    # Query capabilities
    param_type: QueryParameterType = Field(
        ...,
        description="Type of parameters this source accepts",
    )
    url_template: str | None = Field(
        None,
        description="URL template for external links",
    )

    # Technical details
    data_format: str | None = Field(
        None,
        description="Expected data format (json, xml, csv)",
    )
    api_endpoint: str | None = Field(None, description="API endpoint if applicable")

    # Governance
    is_active: bool = Field(
        default=True,
        description="Whether this source is currently available",
    )
    requires_auth: bool = Field(
        default=False,
        description="Whether authentication is required",
    )

    # Usage statistics
    usage_count: int = Field(default=0, description="Number of times tested")
    success_rate: float = Field(
        default=0.0,
        ge=0.0,
        le=1.0,
        description="Success rate of queries",
    )

    # Integration
    source_template_id: UUID | None = Field(
        None,
        description="Linked SourceTemplate if this maps to an ingestible source",
    )

    # Timestamps
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(UTC),
        description="When this catalog entry was created",
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(UTC),
        description="When this catalog entry was last updated",
    )

    @field_validator("tags")
    @classmethod
    def validate_tags(cls, v: list[str]) -> list[str]:
        """Validate and normalize tags."""
        max_tags = 10
        normalized = [tag.strip().lower() for tag in v if tag.strip()]
        if len(normalized) > max_tags:
            msg = f"Maximum {max_tags} tags allowed"
            raise ValueError(msg)
        # Remove duplicates while preserving order
        seen = set()
        deduplicated = []
        for tag in normalized:
            if tag not in seen:
                seen.add(tag)
                deduplicated.append(tag)
        return deduplicated

    def is_testable(self) -> bool:
        """Check if this source can be tested in the workbench."""
        return self.is_active and self.param_type != QueryParameterType.NONE

    def supports_parameter(self, param_type: QueryParameterType) -> bool:
        """Check if this source supports the given parameter type."""
        # API sources support any parameter type
        if self.param_type == QueryParameterType.API:
            return True
        # Exact match
        if self.param_type == param_type:
            return True
        # GeneAndTerm sources support individual gene/term parameters
        return bool(
            self.param_type == QueryParameterType.GENE_AND_TERM
            and param_type
            in [
                QueryParameterType.GENE,
                QueryParameterType.TERM,
                QueryParameterType.GENE_AND_TERM,
            ],
        )


class QueryParameters(BaseModel):
    """
    Domain entity representing parameters for a query test.

    Contains the gene symbol and phenotype/search terms used for testing sources.
    """

    model_config = ConfigDict(frozen=True)

    gene_symbol: str | None = Field(
        None,
        description="Gene symbol to query (e.g., MED13)",
    )
    search_term: str | None = Field(None, description="Phenotype or search term")

    def has_gene(self) -> bool:
        """Check if gene symbol is provided."""
        return self.gene_symbol is not None and self.gene_symbol.strip() != ""

    def has_term(self) -> bool:
        """Check if search term is provided."""
        return self.search_term is not None and self.search_term.strip() != ""

    def can_run_query(self, param_type: QueryParameterType) -> bool:
        """Check if these parameters can run a query of the given type."""
        if param_type == QueryParameterType.GENE:
            return self.has_gene()
        if param_type == QueryParameterType.TERM:
            return self.has_term()
        if param_type == QueryParameterType.GENE_AND_TERM:
            return self.has_gene() and self.has_term()
        if param_type == QueryParameterType.NONE:
            return True
        if param_type == QueryParameterType.API:
            # API sources may have custom validation
            return True
        assert_never(param_type)


class PubMedSortOption(str, Enum):
    """Supported PubMed sort options."""

    RELEVANCE = "relevance"
    PUBLICATION_DATE = "publication_date"
    AUTHOR = "author"
    JOURNAL = "journal"
    TITLE = "title"


class AdvancedQueryParameters(QueryParameters):
    """Extended query parameters with advanced filters."""

    model_config = ConfigDict(frozen=True)

    date_from: date | None = Field(
        default=None,
        description="Earliest publication date to include.",
    )
    date_to: date | None = Field(
        default=None,
        description="Latest publication date to include.",
    )
    publication_types: list[str] = Field(
        default_factory=list,
        description="Publication types (validated against PublicationType).",
    )
    languages: list[str] = Field(
        default_factory=list,
        description="Language filters (ISO codes).",
    )
    sort_by: PubMedSortOption = Field(
        default=PubMedSortOption.RELEVANCE,
        description="Sort order for PubMed results.",
    )
    max_results: int = Field(
        default=100,
        ge=1,
        le=1000,
        description="Maximum number of results to fetch.",
    )
    additional_terms: str | None = Field(
        default=None,
        description="Additional PubMed query syntax appended to the search.",
    )


class QueryParameterCapabilities(BaseModel):
    """Describes which advanced parameters a source supports."""

    model_config = ConfigDict(frozen=True)

    supports_date_range: bool = False
    supports_publication_types: bool = False
    supports_language_filter: bool = False
    supports_sort_options: bool = False
    supports_additional_terms: bool = False
    max_results_limit: int = Field(default=1000, ge=1, le=1000)


class QueryTestResult(BaseModel):
    """
    Domain entity representing the result of a query test.

    Contains the outcome of testing a source with specific parameters.
    """

    model_config = ConfigDict(frozen=True)

    # Identity
    id: UUID = Field(..., description="Unique identifier for this test result")
    catalog_entry_id: str = Field(..., description="ID of the catalog entry tested")
    session_id: UUID = Field(..., description="Workbench session this test belongs to")

    # Test execution
    parameters: QueryParameters = Field(..., description="Parameters used for the test")
    status: TestResultStatus = Field(..., description="Outcome status of the test")

    # Results
    response_data: JSONObject | None = Field(
        None,
        description="Raw response data from the source",
    )
    response_url: str | None = Field(None, description="Generated URL if applicable")
    error_message: str | None = Field(None, description="Error message if test failed")

    # Metadata
    execution_time_ms: int | None = Field(
        None,
        description="Time taken to execute test",
    )
    data_quality_score: float | None = Field(
        None,
        ge=0.0,
        le=1.0,
        description="Quality score of returned data",
    )

    # Timestamps
    started_at: datetime = Field(
        default_factory=lambda: datetime.now(UTC),
        description="When the test started",
    )
    completed_at: datetime | None = Field(None, description="When the test completed")

    def is_successful(self) -> bool:
        """Check if this test was successful."""
        return self.status == TestResultStatus.SUCCESS

    def has_data(self) -> bool:
        """Check if this test returned data."""
        return self.response_data is not None or self.response_url is not None

    def get_duration_ms(self) -> int | None:
        """Get the test duration in milliseconds."""
        if self.completed_at is None:
            return None
        return int((self.completed_at - self.started_at).total_seconds() * 1000)


UpdatePayload = dict[str, object]


class DataDiscoverySession(BaseModel):
    """
    Domain entity representing a user's data discovery session.

    A session tracks a user's discovery and testing activities across
    multiple data sources within a Research Space context.
    """

    model_config = ConfigDict(frozen=True)

    # Identity
    id: UUID = Field(..., description="Unique identifier for the session")
    owner_id: UUID = Field(..., description="User who owns this session")

    # Context
    research_space_id: UUID | None = Field(
        None,
        description="Research Space this session belongs to",
    )
    name: str = Field(
        default="Untitled Session",
        min_length=1,
        max_length=200,
        description="User-friendly session name",
    )

    # Current state
    current_parameters: QueryParameters = Field(
        default_factory=lambda: QueryParameters(
            gene_symbol=None,
            search_term=None,
        ),
        description="Current query parameters for the session",
    )

    # Session data
    tested_sources: list[str] = Field(
        default_factory=list,
        description="IDs of sources that have been tested",
    )
    selected_sources: list[str] = Field(
        default_factory=list,
        description="IDs of sources selected for potential addition",
    )

    # Statistics
    total_tests_run: int = Field(
        default=0,
        description="Total number of tests executed",
    )
    successful_tests: int = Field(default=0, description="Number of successful tests")

    # Lifecycle
    is_active: bool = Field(default=True, description="Whether this session is active")

    # Timestamps
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(UTC),
        description="When the session was created",
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(UTC),
        description="When the session was last updated",
    )
    last_activity_at: datetime = Field(
        default_factory=lambda: datetime.now(UTC),
        description="When the session was last used",
    )

    def _clone_with_updates(self, updates: UpdatePayload) -> "DataDiscoverySession":
        """Internal helper to maintain immutability with typed updates."""
        return self.model_copy(update=updates)

    def update_parameters(self, parameters: QueryParameters) -> "DataDiscoverySession":
        """Create new session with updated parameters."""
        update_payload: UpdatePayload = {
            "current_parameters": parameters,
            "updated_at": datetime.now(UTC),
            "last_activity_at": datetime.now(UTC),
        }
        return self._clone_with_updates(update_payload)

    def record_test(
        self,
        catalog_entry_id: str,
        *,
        success: bool,
    ) -> "DataDiscoverySession":
        """Create new session with test recorded."""
        new_tested_sources = list({*self.tested_sources, catalog_entry_id})
        new_successful_tests = self.successful_tests + (1 if success else 0)

        update_payload: UpdatePayload = {
            "tested_sources": new_tested_sources,
            "total_tests_run": self.total_tests_run + 1,
            "successful_tests": new_successful_tests,
            "updated_at": datetime.now(UTC),
            "last_activity_at": datetime.now(UTC),
        }
        return self._clone_with_updates(update_payload)

    def toggle_source_selection(self, catalog_entry_id: str) -> "DataDiscoverySession":
        """Create new session with source selection toggled."""
        new_selected = (
            [*self.selected_sources, catalog_entry_id]
            if catalog_entry_id not in self.selected_sources
            else [s for s in self.selected_sources if s != catalog_entry_id]
        )

        update_payload: UpdatePayload = {
            "selected_sources": new_selected,
            "updated_at": datetime.now(UTC),
            "last_activity_at": datetime.now(UTC),
        }
        return self._clone_with_updates(update_payload)

    def is_source_selected(self, catalog_entry_id: str) -> bool:
        """Check if a source is selected."""
        return catalog_entry_id in self.selected_sources

    def with_selected_sources(
        self,
        source_ids: Sequence[str],
    ) -> "DataDiscoverySession":
        """
        Create new session with an explicit set of selected sources.

        Args:
            source_ids: Iterable of catalog entry IDs to persist
        """
        deduped: list[str] = []
        seen: set[str] = set()
        for source_id in source_ids:
            if source_id in seen:
                continue
            seen.add(source_id)
            deduped.append(source_id)
        update_payload: UpdatePayload = {
            "selected_sources": deduped,
            "updated_at": datetime.now(UTC),
            "last_activity_at": datetime.now(UTC),
        }
        return self._clone_with_updates(update_payload)

    def is_source_tested(self, catalog_entry_id: str) -> bool:
        """Check if a source has been tested."""
        return catalog_entry_id in self.tested_sources

    def get_success_rate(self) -> float:
        """Calculate success rate for this session."""
        if self.total_tests_run == 0:
            return 0.0
        return self.successful_tests / self.total_tests_run
