"""
Application service for user data source management.

Orchestrates domain services and repositories to implement
data source management use cases with proper business logic.
"""

from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field

from src.domain.entities.source_template import SourceTemplate
from src.domain.entities.user_data_source import (
    IngestionSchedule,
    QualityMetrics,
    SourceConfiguration,
    SourceStatus,
    SourceType,
    UserDataSource,
)
from src.domain.events import (
    DomainEvent,
    DomainEventBus,
    SourceCreatedEvent,
    SourceStatusChangedEvent,
    SourceUpdatedEvent,
    domain_event_bus,
)
from src.domain.repositories.source_template_repository import SourceTemplateRepository
from src.domain.repositories.user_data_source_repository import UserDataSourceRepository
from src.domain.services.source_plugins import SourcePluginRegistry, default_registry
from src.type_definitions.common import StatisticsResponse


class CreateSourceRequest(BaseModel):
    """Request model for creating a new data source."""

    owner_id: UUID
    name: str
    source_type: SourceType
    description: str = ""
    template_id: UUID | None = None
    configuration: SourceConfiguration = Field(
        default_factory=lambda: SourceConfiguration(
            url="",
            file_path="",
            format="",
            auth_type=None,
            auth_credentials={},
            requests_per_minute=None,
            field_mapping={},
            metadata={},
        ),
    )
    tags: list[str] = Field(default_factory=list)
    research_space_id: UUID | None = None

    model_config = ConfigDict(arbitrary_types_allowed=True)


class UpdateSourceRequest(BaseModel):
    """Request model for updating a data source."""

    name: str | None = None
    description: str | None = None
    configuration: SourceConfiguration | None = None
    ingestion_schedule: IngestionSchedule | None = None
    tags: list[str] | None = None

    model_config = ConfigDict(arbitrary_types_allowed=True)


class SourceManagementService:
    """
    Application service for user data source management.

    Orchestrates data source operations including creation, configuration,
    lifecycle management, and quality monitoring.
    """

    def __init__(
        self,
        user_data_source_repository: UserDataSourceRepository,
        source_template_repository: SourceTemplateRepository | None = None,
        plugin_registry: SourcePluginRegistry | None = None,
        event_bus: DomainEventBus | None = None,
    ):
        """
        Initialize the source management service.

        Args:
            user_data_source_repository: Repository for user data sources
            source_template_repository: Repository for source templates
        """
        self._source_repository = user_data_source_repository
        self._template_repository = source_template_repository
        self._plugin_registry = plugin_registry or default_registry
        self._event_bus = event_bus or domain_event_bus

    def _require_template_repository(self) -> SourceTemplateRepository:
        """Ensure the template repository is available."""
        if self._template_repository is None:
            msg = "Source template repository is not configured"
            raise RuntimeError(msg)
        return self._template_repository

    def _apply_plugin_validation(
        self,
        source_type: SourceType,
        configuration: SourceConfiguration,
    ) -> SourceConfiguration:
        plugin = self._plugin_registry.get(source_type)
        if plugin is None:
            return configuration
        return plugin.validate_configuration(configuration)

    def _publish_event(self, event: DomainEvent) -> None:
        """Publish a domain event safely."""
        self._event_bus.publish(event)

    def _determine_changed_fields(self, request: UpdateSourceRequest) -> list[str]:
        """Return a list of changed field names for update events."""
        changed: list[str] = []
        if request.name is not None:
            changed.append("name")
        if request.description is not None:
            changed.append("description")
        if request.configuration is not None:
            changed.append("configuration")
        if request.ingestion_schedule is not None:
            changed.append("ingestion_schedule")
        if request.tags is not None:
            changed.append("tags")
        return changed

    def create_source(self, request: CreateSourceRequest) -> UserDataSource:
        """
        Create a new user data source.

        Args:
            request: Creation request with source details

        Returns:
            The created UserDataSource entity

        Raises:
            ValueError: If validation fails
        """
        # Validate template if provided
        if request.template_id:
            template_repository = self._require_template_repository()
            template = template_repository.find_by_id(request.template_id)
            if not template:
                msg = f"Template {request.template_id} not found"
                raise ValueError(msg)
            if not template.is_available(request.owner_id):
                msg = f"Template {request.template_id} is not available"
                raise ValueError(msg)

        configuration = self._apply_plugin_validation(
            request.source_type,
            request.configuration,
        )

        # Create the source entity
        source = UserDataSource(
            id=UUID(),  # Will be set by repository
            owner_id=request.owner_id,
            research_space_id=request.research_space_id,
            name=request.name,
            description=request.description,
            source_type=request.source_type,
            template_id=request.template_id,
            configuration=configuration,
            tags=request.tags,
            last_ingested_at=None,
        )

        # Save to repository
        saved_source = self._source_repository.save(source)
        self._publish_event(SourceCreatedEvent.from_source(saved_source))
        return saved_source

    def get_source(
        self,
        source_id: UUID,
        owner_id: UUID | None = None,
    ) -> UserDataSource | None:
        """
        Get a data source by ID.

        Args:
            source_id: The source ID
            owner_id: Optional owner filter for security

        Returns:
            The UserDataSource if found and accessible, None otherwise
        """
        source = self._source_repository.find_by_id(source_id)
        if source and owner_id and source.owner_id != owner_id:
            return None  # Not owned by this user
        return source

    def get_user_sources(
        self,
        owner_id: UUID,
        skip: int = 0,
        limit: int = 50,
    ) -> list[UserDataSource]:
        """
        Get all data sources owned by a user.

        Args:
            owner_id: The user ID
            skip: Pagination offset
            limit: Maximum results

        Returns:
            List of user's data sources
        """
        return self._source_repository.find_by_owner(owner_id, skip, limit)

    def update_source(
        self,
        source_id: UUID,
        request: UpdateSourceRequest,
        owner_id: UUID,
    ) -> UserDataSource | None:
        """
        Update a data source.

        Args:
            source_id: The source ID
            request: Update request
            owner_id: The user making the request (for authorization)

        Returns:
            The updated UserDataSource if successful, None if not found or not authorized
        """
        source = self._source_repository.find_by_id(source_id)
        if not source or source.owner_id != owner_id:
            return None

        # Apply updates
        updated_source = source
        if request.name is not None:
            updated_source = updated_source.model_copy(
                update={"name": request.name},
            )
        if request.description is not None:
            updated_source = updated_source.model_copy(
                update={"description": request.description},
            )
        if request.configuration is not None:
            sanitized_config = self._apply_plugin_validation(
                updated_source.source_type,
                request.configuration,
            )
            updated_source = updated_source.update_configuration(sanitized_config)
        if request.ingestion_schedule is not None:
            updated_source = updated_source.model_copy(
                update={"ingestion_schedule": request.ingestion_schedule},
            )
        if request.tags is not None:
            updated_source = updated_source.model_copy(update={"tags": request.tags})

        saved_source = self._source_repository.save(updated_source)
        changed_fields = self._determine_changed_fields(request)
        if changed_fields:
            self._publish_event(
                SourceUpdatedEvent.from_source(
                    saved_source,
                    changed_fields=changed_fields,
                ),
            )
        return saved_source

    def delete_source(self, source_id: UUID, owner_id: UUID) -> bool:
        """
        Delete a data source.

        Args:
            source_id: The source ID
            owner_id: The user making the request (for authorization)

        Returns:
            True if deleted, False if not found or not authorized
        """
        source = self._source_repository.find_by_id(source_id)
        if not source or source.owner_id != owner_id:
            return False

        return self._source_repository.delete(source_id)

    def activate_source(
        self,
        source_id: UUID,
        owner_id: UUID,
    ) -> UserDataSource | None:
        """
        Activate a data source for ingestion.

        Args:
            source_id: The source ID
            owner_id: The user making the request

        Returns:
            The activated source if successful
        """
        source = self._source_repository.find_by_id(source_id)
        if not source or source.owner_id != owner_id:
            return None

        previous_status = source.status
        activated_source = source.update_status(SourceStatus.ACTIVE)
        saved_source = self._source_repository.save(activated_source)
        self._publish_event(
            SourceStatusChangedEvent.from_source(
                saved_source,
                previous_status=previous_status,
            ),
        )
        return saved_source

    def deactivate_source(
        self,
        source_id: UUID,
        owner_id: UUID,
    ) -> UserDataSource | None:
        """
        Deactivate a data source.

        Args:
            source_id: The source ID
            owner_id: The user making the request

        Returns:
            The deactivated source if successful
        """
        source = self._source_repository.find_by_id(source_id)
        if not source or source.owner_id != owner_id:
            return None

        previous_status = source.status
        deactivated_source = source.update_status(SourceStatus.INACTIVE)
        saved_source = self._source_repository.save(deactivated_source)
        self._publish_event(
            SourceStatusChangedEvent.from_source(
                saved_source,
                previous_status=previous_status,
            ),
        )
        return saved_source

    def record_ingestion_success(self, source_id: UUID) -> UserDataSource | None:
        """
        Record successful data ingestion for a source.

        Args:
            source_id: The source ID

        Returns:
            The updated source if found
        """
        return self._source_repository.record_ingestion(source_id)

    def update_quality_metrics(
        self,
        source_id: UUID,
        metrics: QualityMetrics,
    ) -> UserDataSource | None:
        """
        Update quality metrics for a source.

        Args:
            source_id: The source ID
            metrics: The new quality metrics

        Returns:
            The updated source if found
        """
        return self._source_repository.update_quality_metrics(source_id, metrics)

    def get_sources_by_type(
        self,
        source_type: SourceType,
        skip: int = 0,
        limit: int = 50,
    ) -> list[UserDataSource]:
        """
        Get sources by type.

        Args:
            source_type: The source type to filter by
            skip: Pagination offset
            limit: Maximum results

        Returns:
            List of sources of the specified type
        """
        return self._source_repository.find_by_type(source_type, skip, limit)

    def get_active_sources(
        self,
        skip: int = 0,
        limit: int = 50,
    ) -> list[UserDataSource]:
        """
        Get all active sources.

        Args:
            skip: Pagination offset
            limit: Maximum results

        Returns:
            List of active sources
        """
        return self._source_repository.find_active_sources(skip, limit)

    def search_sources(
        self,
        query: str,
        owner_id: UUID | None = None,
        skip: int = 0,
        limit: int = 50,
    ) -> list[UserDataSource]:
        """
        Search sources by name.

        Args:
            query: Search query
            owner_id: Optional owner filter
            skip: Pagination offset
            limit: Maximum results

        Returns:
            List of matching sources
        """
        return self._source_repository.search_by_name(query, owner_id, skip, limit)

    def get_available_templates(
        self,
        user_id: UUID | None = None,
        skip: int = 0,
        limit: int = 50,
    ) -> list[SourceTemplate]:
        """
        Get templates available to a user.

        Args:
            user_id: The user ID (None for anonymous)
            skip: Pagination offset
            limit: Maximum results

        Returns:
            List of available templates
        """
        template_repository = self._require_template_repository()
        return template_repository.find_available_for_user(user_id, skip, limit)

    def get_statistics(self) -> StatisticsResponse:
        """
        Get overall statistics about data sources.

        Returns:
            Dictionary with various statistics
        """
        stats = self._source_repository.get_statistics()
        return {
            "total_sources": stats["total_sources"],
            "status_counts": stats["status_counts"],
            "type_counts": stats["type_counts"],
            "average_quality_score": stats["average_quality_score"],
            "sources_with_quality_metrics": stats["sources_with_quality_metrics"],
        }

    def validate_source_configuration(  # noqa: C901 - validator is intentionally comprehensive
        self,
        source: UserDataSource,
    ) -> list[str]:
        """
        Validate a source's configuration.

        Args:
            source: The source to validate

        Returns:
            List of validation error messages (empty if valid)
        """
        errors = []

        plugin = self._plugin_registry.get(source.source_type)
        if plugin:
            try:
                plugin.validate_configuration(source.configuration)
            except ValueError as exc:  # pragma: no cover - defensive logging path
                errors.append(str(exc))

        # Basic validation
        if not source.name.strip():
            errors.append("Source name cannot be empty")

        name_max_len = 200
        if len(source.name) > name_max_len:
            errors.append("Source name cannot exceed 200 characters")

        # Type-specific validation
        if source.source_type == SourceType.API:
            if not source.configuration.url:
                errors.append("API sources require a URL")
            if (
                source.configuration.requests_per_minute
                and source.configuration.requests_per_minute < 1
            ):
                errors.append("Requests per minute must be at least 1")

        elif source.source_type == SourceType.FILE_UPLOAD:
            if not source.configuration.file_path and not hasattr(
                source.configuration,
                "uploaded_file",
            ):
                errors.append("File upload sources require a file")

        # Template validation
        if source.template_id:
            template_repository = self._require_template_repository()
            template = template_repository.find_by_id(source.template_id)
            if not template:
                errors.append(
                    f"Referenced template {source.template_id} does not exist",
                )
            elif not template.is_available(source.owner_id):
                errors.append(f"Template {source.template_id} is not available")

        return errors
