#!/usr/bin/env python3
"""
Generate TypeScript definitions from Pydantic models.

This script keeps the frontend's shared types in sync with the backend
API schemas described in src/models/api/.
"""

from __future__ import annotations

import argparse
import importlib
import inspect
import sys
import types
from datetime import date, datetime
from enum import Enum
from pathlib import Path
from typing import TYPE_CHECKING, Any, Union, get_args, get_origin
from uuid import UUID

if TYPE_CHECKING:
    from collections.abc import Sequence

    from pydantic.fields import FieldInfo

from pydantic import BaseModel

OUTPUT_PATH = Path("src/web/types/generated.ts")

PRIMITIVE_TYPE_MAP: dict[type[Any], str] = {
    str: "string",
    int: "number",
    float: "number",
    bool: "boolean",
    datetime: "string",
    date: "string",
    UUID: "string",
}


def _load_models(module_path: str) -> Sequence[type[BaseModel]]:
    module = importlib.import_module(module_path)
    models: list[type[BaseModel]] = []
    for _, obj in inspect.getmembers(module, inspect.isclass):
        if issubclass(obj, BaseModel) and obj is not BaseModel:
            models.append(obj)
    return models


UNION_TYPES = (Union, types.UnionType)


def _discover_default_modules(repo_root: Path) -> list[str]:
    base_dir = repo_root / "src/models/api"
    modules: list[str] = []
    if not base_dir.exists():
        return modules
    for path in base_dir.rglob("*.py"):
        if path.name == "__init__.py":
            continue
        rel = path.with_suffix("").relative_to(repo_root)
        modules.append(".".join(rel.parts))
    return sorted(set(modules))


def _parse_args(default_modules: list[str]) -> tuple[list[str], argparse.Namespace]:
    parser = argparse.ArgumentParser(
        description="Generate TypeScript types from MED13 Pydantic models.",
    )
    parser.add_argument(
        "--module",
        action="append",
        default=[],
        help="Additional module path to include (e.g., src.domain.entities.user)",
    )
    args = parser.parse_args()
    modules = sorted(set(default_modules + args.module))
    return modules, args


def _ts_type(annotation: Any) -> str:
    origin = get_origin(annotation)
    if origin is None:
        if isinstance(annotation, type) and issubclass(annotation, BaseModel):
            return annotation.__name__
        if inspect.isclass(annotation) and issubclass(annotation, Enum):
            values = [repr(member.value) for member in annotation]
            return " | ".join(values) if values else "string"
        return PRIMITIVE_TYPE_MAP.get(annotation, "unknown")

    args = get_args(annotation)
    if origin in (list, tuple, set, frozenset):
        inner = _ts_type(args[0]) if args else "unknown"
        return (
            f"{inner}[]"
            if origin is not tuple
            else "[" + ", ".join(_ts_type(arg) for arg in args) + "]"
        )
    if origin in (dict,):
        key_type = _ts_type(args[0]) if args else "string"
        value_type = _ts_type(args[1]) if len(args) > 1 else "unknown"
        if key_type != "string":
            key_type = "string"
        return f"Record<{key_type}, {value_type}>"
    if origin is tuple(get_args(origin)) and hasattr(origin, "__origin__"):
        return "unknown"
    if origin in UNION_TYPES:
        ts_parts = []
        include_null = False
        for arg in args:
            if arg is type(None):
                include_null = True
            else:
                ts_parts.append(_ts_type(arg))
        union = " | ".join(sorted(set(ts_parts))) or "unknown"
        return f"{union} | null" if include_null else union
    return "unknown"


def _render_field(name: str, field: FieldInfo) -> str:
    optional = "?" if not field.is_required() else ""
    ts_type = _ts_type(field.annotation)
    return f"  {name}{optional}: {ts_type};"


def _render_interface(model: type[BaseModel]) -> str:
    lines = [f"export interface {model.__name__} {{"]
    for field_name, field in model.model_fields.items():
        lines.append(_render_field(field_name, field))
    lines.append("}")
    return "\n".join(lines)


def main() -> None:
    repo_root = Path(__file__).resolve().parents[1]
    if str(repo_root) not in sys.path:
        sys.path.append(str(repo_root))

    OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)

    module_names, _ = _parse_args(_discover_default_modules(repo_root))

    models: list[type[BaseModel]] = []
    for module in module_names:
        models.extend(_load_models(module))

    if not models:
        msg = "No Pydantic models discovered for TypeScript generation"
        raise RuntimeError(msg)

    contents = [
        "// Auto-generated by scripts/generate_ts_types.py. Do not edit.",
        "/* eslint-disable */",
        "/* prettier-ignore */",
        "",
    ]

    for model in models:
        contents.append(_render_interface(model))
        contents.append("")

    OUTPUT_PATH.write_text("\n".join(contents).rstrip() + "\n", encoding="utf-8")
    # Note: print is acceptable in script files
    print(f"âœ… Wrote TypeScript types to {OUTPUT_PATH}")  # noqa: T201


if __name__ == "__main__":
    main()
